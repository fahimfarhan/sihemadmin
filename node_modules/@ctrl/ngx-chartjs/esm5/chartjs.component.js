/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, NgZone, Output, ViewChild, } from '@angular/core';
var ChartjsComponent = /** @class */ (function () {
    function ChartjsComponent(zone) {
        this.zone = zone;
        this.chartClick = new EventEmitter();
        /**
         * chart type
         */
        this.type = 'doughnut';
        this.height = 150;
        this.width = 300;
        this.legend = {
            display: true,
            position: 'bottom',
        };
        this.options = {};
        this.redraw = false;
        this.datasetKeyProvider = (/**
         * @param {?} d
         * @return {?}
         */
        function (d) { return d.label; });
    }
    /**
     * @return {?}
     */
    ChartjsComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.renderChart();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    ChartjsComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.firstChange) {
            return;
        }
        if (this.chartInstance && this.redraw) {
            this.chartInstance.destroy();
            this.renderChart();
            return;
        }
        this.updateChart();
    };
    /**
     * @return {?}
     */
    ChartjsComponent.prototype.updateChart = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var data = this.transformData();
        if (!this.chartInstance) {
            return;
        }
        if (this.options) {
            // in order to allow for universal rendering, we import chart.js runtime with `require` to prevent node errors
            /** @type {?} */
            var Chart_1 = require('chart.js');
            this.chartInstance.options = ((/** @type {?} */ (Chart_1))).helpers.configMerge(this.chartInstance.options, this.options);
        }
        // Pipe datasets to chart instance datasets enabling
        // seamless transitions
        /** @type {?} */
        var currentDatasets = (this.chartInstance.config.data &&
            this.chartInstance.config.data.datasets) ||
            [];
        /** @type {?} */
        var nextDatasets = data.datasets || [];
        /** @type {?} */
        var currentDatasetsIndexed = {};
        currentDatasets.forEach((/**
         * @param {?} x
         * @return {?}
         */
        function (x) {
            currentDatasetsIndexed[_this.datasetKeyProvider(x)] = x;
        }));
        // We can safely replace the dataset array, as long as we retain the _meta property
        // on each dataset.
        this.chartInstance.config.data.datasets = nextDatasets.map((/**
         * @param {?} next
         * @return {?}
         */
        function (next) {
            var e_1, _a, e_2, _b;
            /** @type {?} */
            var current = currentDatasetsIndexed[_this.datasetKeyProvider(next)];
            if (current && current.type === next.type) {
                try {
                    // Reassign all properties from next
                    for (var _c = tslib_1.__values(Object.keys(next)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var nextProp = _d.value;
                        // Data array can't be reassigned here.
                        if (nextProp !== 'data') {
                            current[nextProp] = next[nextProp];
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                try {
                    // Remove properties from current if they was removed in next
                    for (var _e = tslib_1.__values(Object.keys(current)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var currentProp = _f.value;
                        // Be careful with _meta property
                        if (!next.hasOwnProperty(currentProp) && currentProp !== '_meta') {
                            delete current[currentProp];
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                // The data array must be edited in place. As chart.js adds listeners to it.
                current.data.splice(next.data.length);
                next.data.forEach((/**
                 * @param {?} point
                 * @param {?} pid
                 * @return {?}
                 */
                function (point, pid) {
                    current.data[pid] = next.data[pid];
                }));
                return current;
            }
            return next;
        }));
        var datasets = data.datasets, rest = tslib_1.__rest(data, ["datasets"]);
        this.chartInstance.config.data = tslib_1.__assign({}, this.chartInstance.config.data, rest);
        this.chartInstance.update();
    };
    /**
     * @return {?}
     */
    ChartjsComponent.prototype.renderChart = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var node = this.ref.nativeElement;
        /** @type {?} */
        var data = this.transformData();
        if (typeof this.legend !== 'undefined') {
            /** @type {?} */
            var legendOptions = tslib_1.__assign({}, this.legend, this.options.legend);
            this.options.legend = legendOptions;
        }
        // in order to allow for universal rendering, we import Codemirror runtime with `require` to prevent node errors
        /** @type {?} */
        var Chart = require('chart.js');
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        function () {
            _this.chartInstance = new Chart(node, {
                type: _this.type,
                data: data,
                options: _this.options,
                plugins: _this.plugins,
            });
        }));
    };
    /**
     * @return {?}
     */
    ChartjsComponent.prototype.transformData = /**
     * @return {?}
     */
    function () {
        if (!this.data) {
            return;
        }
        if (typeof this.data === 'function') {
            /** @type {?} */
            var node = this.ref;
            return this.data(node);
        }
        return this.data;
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    ChartjsComponent.prototype.handleOnClick = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.chartClick.emit({
            elements: this.chartInstance.getElementsAtEvent($event),
            element: this.chartInstance.getElementAtEvent($event),
            dataset: this.chartInstance.getDatasetAtEvent($event),
            $event: $event,
        });
    };
    ChartjsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-chartjs',
                    template: "\n  <!-- wrapping div required for height, width to work -->\n  <div>\n    <canvas\n      #ref\n      [attr.height]=\"height\"\n      [attr.width]=\"width\"\n      (click)=\"handleOnClick($event)\"\n    ></canvas>\n  </div>\n  ",
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    ChartjsComponent.ctorParameters = function () { return [
        { type: NgZone }
    ]; };
    ChartjsComponent.propDecorators = {
        ref: [{ type: ViewChild, args: ['ref',] }],
        chartClick: [{ type: Output }],
        type: [{ type: Input }],
        data: [{ type: Input }],
        height: [{ type: Input }],
        width: [{ type: Input }],
        legend: [{ type: Input }],
        options: [{ type: Input }],
        plugins: [{ type: Input }],
        redraw: [{ type: Input }],
        datasetKeyProvider: [{ type: Input }]
    };
    return ChartjsComponent;
}());
export { ChartjsComponent };
if (false) {
    /** @type {?} */
    ChartjsComponent.prototype.chartInstance;
    /** @type {?} */
    ChartjsComponent.prototype.ref;
    /** @type {?} */
    ChartjsComponent.prototype.chartClick;
    /**
     * chart type
     * @type {?}
     */
    ChartjsComponent.prototype.type;
    /** @type {?} */
    ChartjsComponent.prototype.data;
    /** @type {?} */
    ChartjsComponent.prototype.height;
    /** @type {?} */
    ChartjsComponent.prototype.width;
    /** @type {?} */
    ChartjsComponent.prototype.legend;
    /** @type {?} */
    ChartjsComponent.prototype.options;
    /** @type {?} */
    ChartjsComponent.prototype.plugins;
    /** @type {?} */
    ChartjsComponent.prototype.redraw;
    /** @type {?} */
    ChartjsComponent.prototype.datasetKeyProvider;
    /**
     * @type {?}
     * @private
     */
    ChartjsComponent.prototype.zone;
}
/**
 * @record
 */
export function ChartClickEvent() { }
if (false) {
    /** @type {?} */
    ChartClickEvent.prototype.elements;
    /** @type {?} */
    ChartClickEvent.prototype.element;
    /** @type {?} */
    ChartClickEvent.prototype.dataset;
    /** @type {?} */
    ChartClickEvent.prototype.$event;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnRqcy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AY3RybC9uZ3gtY2hhcnRqcy8iLCJzb3VyY2VzIjpbImNoYXJ0anMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUVMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUVOLE1BQU0sRUFDTixTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFVdkI7SUFrQ0UsMEJBQW9CLElBQVk7UUFBWixTQUFJLEdBQUosSUFBSSxDQUFRO1FBaEJ0QixlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQW1CLENBQUM7Ozs7UUFFbEQsU0FBSSxHQUF1QixVQUFVLENBQUM7UUFFdEMsV0FBTSxHQUFHLEdBQUcsQ0FBQztRQUNiLFVBQUssR0FBRyxHQUFHLENBQUM7UUFFckIsV0FBTSxHQUE2QjtZQUNqQyxPQUFPLEVBQUUsSUFBSTtZQUNiLFFBQVEsRUFBRSxRQUFRO1NBQ25CLENBQUM7UUFDTyxZQUFPLEdBQXVCLEVBQUUsQ0FBQztRQUVqQyxXQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ2YsdUJBQWtCOzs7O1FBQXVCLFVBQUEsQ0FBQyxJQUFJLE9BQUEsQ0FBQyxDQUFDLEtBQUssRUFBUCxDQUFPLEVBQUM7SUFFNUIsQ0FBQzs7OztJQUVwQywwQ0FBZTs7O0lBQWY7UUFDRSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDckIsQ0FBQzs7Ozs7SUFDRCxzQ0FBVzs7OztJQUFYLFVBQVksT0FBWTtRQUN0QixJQUFJLE9BQU8sQ0FBQyxXQUFXLEVBQUU7WUFDdkIsT0FBTztTQUNSO1FBQ0QsSUFBSSxJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDckMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUM3QixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDbkIs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ImltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE5nWm9uZSxcbiAgT25DaGFuZ2VzLFxuICBPdXRwdXQsXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBDaGFydERhdGEsXG4gIENoYXJ0TGVnZW5kT3B0aW9ucyxcbiAgQ2hhcnRPcHRpb25zLFxuICBDaGFydFR5cGUsXG59IGZyb20gJ2NoYXJ0LmpzJztcblxuZGVjbGFyZSB2YXIgcmVxdWlyZTogYW55O1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICduZ3gtY2hhcnRqcycsXG4gIHRlbXBsYXRlOiBgXG4gIDwhLS0gd3JhcHBpbmcgZGl2IHJlcXVpcmVkIGZvciBoZWlnaHQsIHdpZHRoIHRvIHdvcmsgLS0+XG4gIDxkaXY+XG4gICAgPGNhbnZhc1xuICAgICAgI3JlZlxuICAgICAgW2F0dHIuaGVpZ2h0XT1cImhlaWdodFwiXG4gICAgICBbYXR0ci53aWR0aF09XCJ3aWR0aFwiXG4gICAgICAoY2xpY2spPVwiaGFuZGxlT25DbGljaygkZXZlbnQpXCJcbiAgICA+PC9jYW52YXM+XG4gIDwvZGl2PlxuICBgLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgQ2hhcnRqc0NvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uQ2hhbmdlcyB7XG4gIGNoYXJ0SW5zdGFuY2U6IGFueTtcbiAgQFZpZXdDaGlsZCgncmVmJykgcmVmOiBFbGVtZW50UmVmPEhUTUxDYW52YXNFbGVtZW50PjtcbiAgQE91dHB1dCgpIGNoYXJ0Q2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyPENoYXJ0Q2xpY2tFdmVudD4oKTtcbiAgLyoqIGNoYXJ0IHR5cGUgKi9cbiAgQElucHV0KCkgdHlwZTogQ2hhcnRUeXBlIHwgc3RyaW5nID0gJ2RvdWdobnV0JztcbiAgQElucHV0KCkgZGF0YTogQ2hhcnREYXRhIHwgYW55O1xuICBASW5wdXQoKSBoZWlnaHQgPSAxNTA7XG4gIEBJbnB1dCgpIHdpZHRoID0gMzAwO1xuICBASW5wdXQoKVxuICBsZWdlbmQ6IENoYXJ0TGVnZW5kT3B0aW9ucyB8IGFueSA9IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIHBvc2l0aW9uOiAnYm90dG9tJyxcbiAgfTtcbiAgQElucHV0KCkgb3B0aW9uczogQ2hhcnRPcHRpb25zIHwgYW55ID0ge307XG4gIEBJbnB1dCgpIHBsdWdpbnM6IGFueVtdO1xuICBASW5wdXQoKSByZWRyYXcgPSBmYWxzZTtcbiAgQElucHV0KCkgZGF0YXNldEtleVByb3ZpZGVyOiAoeDogYW55KSA9PiBzdHJpbmcgPSBkID0+IGQubGFiZWw7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB6b25lOiBOZ1pvbmUpIHt9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMucmVuZGVyQ2hhcnQoKTtcbiAgfVxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBhbnkpIHtcbiAgICBpZiAoY2hhbmdlcy5maXJzdENoYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGFydEluc3RhbmNlICYmIHRoaXMucmVkcmF3KSB7XG4gICAgICB0aGlzLmNoYXJ0SW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUNoYXJ0KCk7XG4gIH1cblxuICB1cGRhdGVDaGFydCgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy50cmFuc2Zvcm1EYXRhKCk7XG5cbiAgICBpZiAoIXRoaXMuY2hhcnRJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgIC8vIGluIG9yZGVyIHRvIGFsbG93IGZvciB1bml2ZXJzYWwgcmVuZGVyaW5nLCB3ZSBpbXBvcnQgY2hhcnQuanMgcnVudGltZSB3aXRoIGByZXF1aXJlYCB0byBwcmV2ZW50IG5vZGUgZXJyb3JzXG4gICAgICBjb25zdCBDaGFydCA9IHJlcXVpcmUoJ2NoYXJ0LmpzJyk7XG4gICAgICB0aGlzLmNoYXJ0SW5zdGFuY2Uub3B0aW9ucyA9IChDaGFydCBhcyBhbnkpLmhlbHBlcnMuY29uZmlnTWVyZ2UoXG4gICAgICAgIHRoaXMuY2hhcnRJbnN0YW5jZS5vcHRpb25zLFxuICAgICAgICB0aGlzLm9wdGlvbnMsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFBpcGUgZGF0YXNldHMgdG8gY2hhcnQgaW5zdGFuY2UgZGF0YXNldHMgZW5hYmxpbmdcbiAgICAvLyBzZWFtbGVzcyB0cmFuc2l0aW9uc1xuICAgIGNvbnN0IGN1cnJlbnREYXRhc2V0czogYW55W10gPVxuICAgICAgKHRoaXMuY2hhcnRJbnN0YW5jZS5jb25maWcuZGF0YSAmJlxuICAgICAgICB0aGlzLmNoYXJ0SW5zdGFuY2UuY29uZmlnLmRhdGEuZGF0YXNldHMpIHx8XG4gICAgICBbXTtcbiAgICBjb25zdCBuZXh0RGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuXG4gICAgY29uc3QgY3VycmVudERhdGFzZXRzSW5kZXhlZCA9IHt9O1xuICAgIGN1cnJlbnREYXRhc2V0cy5mb3JFYWNoKCh4KSA9PiB7XG4gICAgICBjdXJyZW50RGF0YXNldHNJbmRleGVkW3RoaXMuZGF0YXNldEtleVByb3ZpZGVyKHgpXSA9IHg7XG4gICAgfSk7XG5cbiAgICAvLyBXZSBjYW4gc2FmZWx5IHJlcGxhY2UgdGhlIGRhdGFzZXQgYXJyYXksIGFzIGxvbmcgYXMgd2UgcmV0YWluIHRoZSBfbWV0YSBwcm9wZXJ0eVxuICAgIC8vIG9uIGVhY2ggZGF0YXNldC5cbiAgICB0aGlzLmNoYXJ0SW5zdGFuY2UuY29uZmlnLmRhdGEuZGF0YXNldHMgPSBuZXh0RGF0YXNldHMubWFwKG5leHQgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IGN1cnJlbnREYXRhc2V0c0luZGV4ZWRbdGhpcy5kYXRhc2V0S2V5UHJvdmlkZXIobmV4dCldO1xuXG4gICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LnR5cGUgPT09IG5leHQudHlwZSkge1xuICAgICAgICAvLyBSZWFzc2lnbiBhbGwgcHJvcGVydGllcyBmcm9tIG5leHRcbiAgICAgICAgZm9yIChjb25zdCBuZXh0UHJvcCBvZiBPYmplY3Qua2V5cyhuZXh0KSkge1xuICAgICAgICAgIC8vIERhdGEgYXJyYXkgY2FuJ3QgYmUgcmVhc3NpZ25lZCBoZXJlLlxuICAgICAgICAgIGlmIChuZXh0UHJvcCAhPT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICBjdXJyZW50W25leHRQcm9wXSA9IG5leHRbbmV4dFByb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgcHJvcGVydGllcyBmcm9tIGN1cnJlbnQgaWYgdGhleSB3YXMgcmVtb3ZlZCBpbiBuZXh0XG4gICAgICAgIGZvciAoY29uc3QgY3VycmVudFByb3Agb2YgT2JqZWN0LmtleXMoY3VycmVudCkpIHtcbiAgICAgICAgICAvLyBCZSBjYXJlZnVsIHdpdGggX21ldGEgcHJvcGVydHlcbiAgICAgICAgICBpZiAoIW5leHQuaGFzT3duUHJvcGVydHkoY3VycmVudFByb3ApICYmIGN1cnJlbnRQcm9wICE9PSAnX21ldGEnKSB7XG4gICAgICAgICAgICBkZWxldGUgY3VycmVudFtjdXJyZW50UHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBkYXRhIGFycmF5IG11c3QgYmUgZWRpdGVkIGluIHBsYWNlLiBBcyBjaGFydC5qcyBhZGRzIGxpc3RlbmVycyB0byBpdC5cbiAgICAgICAgY3VycmVudC5kYXRhLnNwbGljZShuZXh0LmRhdGEubGVuZ3RoKTtcbiAgICAgICAgbmV4dC5kYXRhLmZvckVhY2goKHBvaW50LCBwaWQpID0+IHtcbiAgICAgICAgICBjdXJyZW50LmRhdGFbcGlkXSA9IG5leHQuZGF0YVtwaWRdO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0pO1xuXG4gICAgY29uc3QgeyBkYXRhc2V0cywgLi4ucmVzdCB9ID0gZGF0YTtcblxuICAgIHRoaXMuY2hhcnRJbnN0YW5jZS5jb25maWcuZGF0YSA9IHtcbiAgICAgIC4uLnRoaXMuY2hhcnRJbnN0YW5jZS5jb25maWcuZGF0YSxcbiAgICAgIC4uLnJlc3QsXG4gICAgfTtcblxuICAgIHRoaXMuY2hhcnRJbnN0YW5jZS51cGRhdGUoKTtcbiAgfVxuXG4gIHJlbmRlckNoYXJ0KCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnRyYW5zZm9ybURhdGEoKTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5sZWdlbmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBsZWdlbmRPcHRpb25zID0geyAuLi50aGlzLmxlZ2VuZCwgLi4udGhpcy5vcHRpb25zLmxlZ2VuZCB9O1xuICAgICAgdGhpcy5vcHRpb25zLmxlZ2VuZCA9IGxlZ2VuZE9wdGlvbnM7XG4gICAgfVxuXG4gICAgLy8gaW4gb3JkZXIgdG8gYWxsb3cgZm9yIHVuaXZlcnNhbCByZW5kZXJpbmcsIHdlIGltcG9ydCBDb2RlbWlycm9yIHJ1bnRpbWUgd2l0aCBgcmVxdWlyZWAgdG8gcHJldmVudCBub2RlIGVycm9yc1xuICAgIGNvbnN0IENoYXJ0ID0gcmVxdWlyZSgnY2hhcnQuanMnKTtcblxuICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICB0aGlzLmNoYXJ0SW5zdGFuY2UgPSBuZXcgQ2hhcnQobm9kZSwge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcGx1Z2luczogdGhpcy5wbHVnaW5zLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICB0cmFuc2Zvcm1EYXRhKCkge1xuICAgIGlmICghdGhpcy5kYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5yZWY7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG5cbiAgaGFuZGxlT25DbGljaygkZXZlbnQ6IEV2ZW50KSB7XG4gICAgdGhpcy5jaGFydENsaWNrLmVtaXQoe1xuICAgICAgZWxlbWVudHM6IHRoaXMuY2hhcnRJbnN0YW5jZS5nZXRFbGVtZW50c0F0RXZlbnQoJGV2ZW50KSxcbiAgICAgIGVsZW1lbnQ6IHRoaXMuY2hhcnRJbnN0YW5jZS5nZXRFbGVtZW50QXRFdmVudCgkZXZlbnQpLFxuICAgICAgZGF0YXNldDogdGhpcy5jaGFydEluc3RhbmNlLmdldERhdGFzZXRBdEV2ZW50KCRldmVudCksXG4gICAgICAkZXZlbnQsXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGFydENsaWNrRXZlbnQge1xuICBlbGVtZW50czogYW55W107XG4gIGVsZW1lbnQ6IGFueTtcbiAgZGF0YXNldDogYW55W107XG4gICRldmVudDogRXZlbnQ7XG59XG4iXX0=